<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="Last-Modified" content="0">
    <meta http-equiv="If-Modified-Since" content="0">
    <meta http-equiv="Cache-Control" content="private, no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="-1">
    <title>Block Editor - Roblox API</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <script src="https://unpkg.com/blockly@10.4.3/blockly.min.js"></script>
    <script src="https://unpkg.com/blockly@10.4.3/javascript_compressed.js"></script>
    <script src="blockly_parser.js"></script>
    <script>
        // Unique build tag changes each edit to force WebView2 to see file difference
        window.__BUILD_TAG = 'build-20250910-' + Math.random().toString(36).slice(2,9);
    </script>
    <script>
        const loadTime = new Date().toISOString();
        console.log('HTML loaded at:', loadTime);
        document.title = 'Block Editor - Roblox API ' + window.__BUILD_TAG;
        
        document.addEventListener('DOMContentLoaded', function() {
            const output = document.getElementById('output');
            if (output) {
                output.textContent = '// ROBLOX API - Page loaded at: ' + loadTime + '\n// Output will appear here\n';
            }
            
            console.log('Checking Roblox block definitions...');
            console.log('get_service block:', Blockly.Blocks['get_service'] ? 'FOUND' : 'MISSING');
            console.log('find_first_child block:', Blockly.Blocks['find_first_child'] ? 'FOUND' : 'MISSING');
            console.log('RobloxAPI object:', window.RobloxAPI ? 'FOUND' : 'MISSING');
        });
    </script>
    <script>
        (function(){
            if (window.chrome && window.chrome.webview){
                try {
                    window.chrome.webview.addEventListener('message', function(e){
                        try { window.dispatchEvent(new MessageEvent('message',{ data: e.data })); } catch(_) {}
                    });
                } catch(_) {}
            }
        })();
    </script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #0d1117 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
            display:flex;
            flex-direction:column;
        }
        .main-container {
            display: flex;
            flex:1 1 auto;
            min-height:0;
            gap: 4px;
            padding: 4px;
        }
        
        .editor-section {
            flex: 2.2;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 1;
        }
        
        .output-section {
            flex: 0 1 560px;
            max-width: 640px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 1000;
            pointer-events: auto;
            overflow-x: auto;
        }
        
        .button-container {
            pointer-events: auto !important;
        }
        
        .button-container button {
            pointer-events: auto !important;
            position: relative !important;
        }
        
        .blocklyWidgetDiv, .blocklyTooltipDiv, .blocklyDropDownDiv {
            z-index: 999 !important;
        }
    .blocklyMainBackground { fill:#161b22 !important; }
    .blocklySvg { background:#0d1117 !important; }
    #blocklyDiv { background:#0d1117 !important; }
    
    
    :root { --bg-workspace:#141414; --bg-toolbox:#292929; --bg-flyout:#3d3d3d; }
    .blocklySvg { background:var(--bg-workspace)!important; }
    .blocklyMainBackground { fill:var(--bg-workspace)!important; }
    .blocklyToolboxDiv, .blocklyToolboxContents, .blocklyTree { background:var(--bg-toolbox)!important; }
    .blocklyToolboxDiv { border-right:1px solid #1e1e1e !important; }
    .blocklyFlyout, .blocklyFlyoutBackground { background:var(--bg-flyout)!important; fill:var(--bg-flyout)!important; }
    .blocklyFlyout { box-shadow:0 0 0 1px #2a2a2a, 0 4px 12px rgba(0,0,0,0.55)!important; }
    .blocklyFlyout .blocklyText { fill:#f0f6fc!important; }
    .blocklyTreeRow { transition:background .15s ease; }
    .blocklyTreeRow:hover { background:#182027!important; }
    .blocklyTreeRow.blocklyTreeSelected { background:#1a242c!important; }
    
    .blocklyToolboxDiv { background:#161b22 !important; border-right:1px solid #222 !important; }
    .blocklyTreeRow { background:transparent !important; color:#f0f6fc !important; }
    .blocklyTreeRow:hover { background:#21262d !important; }
    .blocklyTreeRow.blocklyTreeSelected { background:#238636 !important; color:#fff !important; }
    .blocklyFlyout { background:#161b22 !important; }
    .blocklyFlyoutBackground { fill:#161b22 !important; }
    .blocklyFlyoutLabelText { fill:#f0f6fc !important; }
    .blocklyFlyoutButton .blocklyText { fill:#f0f6fc !important; }
    .blocklyScrollbarHandle { fill:#30363d !important; }
    .blocklyScrollbarBackground { fill:rgba(255,255,255,0.05) !important; }
    .blocklyWidgetDiv .goog-menu { background:#161b22 !important; color:#f0f6fc !important; }
    .blocklyWidgetDiv .goog-menuitem { color:#f0f6fc !important; }
    .blocklyWidgetDiv .goog-menuitem-hover, .blocklyWidgetDiv .goog-menuitem-highlight { background:#238636 !important; color:#fff !important; }
    .blocklyToolboxContents, .blocklyTree { background:#161b22 !important; }
    .blocklyToolboxCategory .blocklyTreeRow { border-left:4px solid transparent !important; }
    .blocklyToolboxCategory.selected .blocklyTreeRow { border-left:4px solid #00d4aa !important; background:#0d1117 !important; }
    .blocklyDropDownDiv { background:#161b22 !important; color:#f0f6fc !important; border:1px solid #30363d !important; }
    .blocklyDropDownDiv .blocklyDropDownContent { background:#161b22 !important; }
    .blocklyDropDownDiv .goog-menuitem { color:#f0f6fc !important; }
    .blocklyDropDownDiv .goog-menuitem-highlight, .blocklyDropDownDiv .goog-menuitem-hover { background:#238636 !important; color:#fff !important; }
    </style>
</head>
<body>
    <div id="tabsBar" style="display:flex; gap:4px; overflow-x:hidden; padding:6px 6px 6px 6px; scrollbar-width:thin; background:#0d1117; border-bottom:1px solid #1e242b; position:relative; flex:0 0 auto;">
        <div id="addTabBtn" style="flex:0 0 auto; cursor:pointer; background:#238636; color:#fff; font-size:14px; padding:4px 12px; border-radius:4px; user-select:none; font-weight:600;">+</div>
    </div>
    <div class="main-container">
        <div class="editor-section">
            <div id="blocklyDiv" style="height:100%; width:100%;"></div>
        </div>
        <div class="output-section">
                <div id="versionBanner" style="background:#00d4aa; color:#000; padding:4px; border-radius:4px; margin-bottom:4px; font-size:10px; font-weight:bold; text-align:center;">
                    🎮 ROBLOX API v1.1.1
                </div>
            <div class="code-preview" style="flex:1; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:6px; padding:0; overflow:hidden; font-family:Consolas,monospace; font-size:11px; position:relative;">
                <div class="code-header" style="font-weight:600; margin:6px; margin-bottom:2px; font-size:10px; color:#00d4aa;">Program JSON (Columns)</div>
                <div class="code-editor" style="position:relative; height:calc(100% - 22px);">
                    <textarea id="codeInput" spellcheck="false" style="width:100%; height:100%; margin:0; padding:6px; background:rgba(0,0,0,0.3); color:#f0f6fc; caret-color:#f0f6fc; border:none; outline:none; resize:none; line-height:1.3; font-family:Consolas,monospace; font-size:11px; overflow:auto;">// Generated code will appear here</textarea>
                </div>
            </div>
            <div class="output-display" style="flex:1; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:6px; padding:6px; overflow:auto; font-family:Consolas,monospace; font-size:11px; margin-top:4px;">
                <div class="output-header" style="font-weight:600; margin-bottom:2px; font-size:10px; color:#00d4aa;">Output</div>
                <div id="output" style="margin:0; white-space:pre-wrap; line-height:1.3;">// Output will appear here</div>
            </div>
            <div class="button-container" style="margin-top:4px; display:flex; gap:4px; position:relative; z-index:1001; pointer-events:auto;">
                <button id="runBtn" style="flex:1; background:#238636; color:#f0f6fc; border:1px solid #2ea043; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px; position:relative; z-index:1002; pointer-events:auto;">Run</button>
                <button id="stopBtn" style="background:#da3633; color:#f0f6fc; border:1px solid #f85149; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px; position:relative; z-index:1002; pointer-events:auto; display:none;">Stop</button>
                <button id="clearBtn" style="background:#656d76; color:#f0f6fc; border:1px solid #8b949e; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px; position:relative; z-index:1002; pointer-events:auto;">Clear</button>
                <button id="refreshBtn" style="background:#656d76; color:#f0f6fc; border:1px solid #8b949e; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px; position:relative; z-index:1002; pointer-events:auto;" title="Force refresh page">↻</button>
                <button id="exportBlocksBtn" style="background:#3b82f6; color:#f0f6fc; border:1px solid #2563eb; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px; position:relative; z-index:1002; pointer-events:auto;" title="Export JSON">Export</button>
                <button id="importBlocksBtn" style="background:#9333ea; color:#f0f6fc; border:1px solid #7e22ce; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px; position:relative; z-index:1002; pointer-events:auto;" title="Import JSON">Import</button>
            </div>
        </div>
    </div>
    <script>
    window.__APP_VERSION = '1.1.2';
        const vb = document.getElementById('versionBanner');
        if (vb) vb.textContent = '🎮 ROBLOX API v' + window.__APP_VERSION;
    </script>
    <script>
        // Auto-update from GitHub on startup
        async function checkForUpdate() {
            try {
                console.log('Checking for updates from GitHub...');
                const response = await fetch('https://raw.githubusercontent.com/your-username/your-repo/main/web/index.html', {
                    cache: 'no-cache',
                    headers: {'Cache-Control': 'no-cache'}
                });
                
                if (response.ok) {
                    const newContent = await response.text();
                    if (newContent && newContent.length > 1000) { // Basic sanity check
                        console.log('✅ Updated HTML downloaded from GitHub');
                        if (window.chrome && window.chrome.webview) {
                            window.chrome.webview.postMessage({
                                type: 'updateHTML',
                                content: newContent
                            });
                        }
                    }
                } else {
                    console.log('⚠️ GitHub update failed, using cached version');
                }
            } catch (error) {
                console.log('⚠️ No internet connection, using cached version');
            }
        }
        
        // Check for updates on load
        checkForUpdate();
        
        // Script Generator Loaded
        
        // Add manual refresh capability with F5 or Ctrl+R
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F5' || (e.ctrlKey && e.key === 'r')) {
                e.preventDefault();
                location.reload(true); // Force reload
            }
        });
        
        // Debug: Log all clicks to see what's intercepting them
        document.addEventListener('click', function(e) {
            console.log('Click detected on:', e.target, 'at coordinates:', e.clientX, e.clientY);
        }, true);
        
        document.addEventListener('DOMContentLoaded', ()=>{

            const runBtn = document.getElementById('runBtn');
            const stopBtn = document.getElementById('stopBtn');
            const clearBtn = document.getElementById('clearBtn');
            const refreshBtn = document.getElementById('refreshBtn');
            const codeInput = document.getElementById('codeInput');

            
            // Debug: Log button elements to ensure they exist
            console.log('Buttons found:', {runBtn, stopBtn, clearBtn, refreshBtn});
            
            // Ensure buttons are properly configured
            [runBtn, stopBtn, clearBtn, refreshBtn].forEach((btn, index) => {
                if (btn) {
                    btn.style.pointerEvents = 'auto';
                    btn.style.position = 'relative';
                    btn.style.zIndex = '1002';
                    
                    // Add debug event listeners
                    btn.addEventListener('mouseenter', () => console.log(`Button ${index} mouse enter`));
                    btn.addEventListener('mouseleave', () => console.log(`Button ${index} mouse leave`));
                    btn.addEventListener('mousedown', () => console.log(`Button ${index} mouse down`));
                    btn.addEventListener('mouseup', () => console.log(`Button ${index} mouse up`));
                }
            });

            function generateCode(){
                // Generate JS from workspace with proper init/finish
                const ws = Blockly.getMainWorkspace();
                Blockly.JavaScript.init(ws);
                let code = Blockly.JavaScript.workspaceToCode(ws);
                code = Blockly.JavaScript.finish(code);
                // Remove or shrink mass single-letter declarations (var a, b, c, ... , z;) keeping only actually used ones.
                code = (function(opt){
                    const lines = opt.split(/\n/);
                    for (let i=0;i<lines.length;i++){
                        const raw = lines[i];
                        const trimmed = raw.trim();
                        // Flexible detect: starts with var and only comma-separated single letters (>= 10) including 'a'..'z'
                        if(/^var\s+([a-z]\s*,\s*){10,}[a-z]\s*;?$/.test(trimmed)){
                            const remainder = lines.slice(i+1).join('\n');
                            const keep=[]; const letters='abcdefghijklmnopqrstuvwxyz';
                            for (const ch of letters){ if(new RegExp('\\b'+ch+'\\b').test(remainder)) keep.push(ch); }
                            lines[i] = keep.length ? ('var '+keep.join(', ')+';') : '';
                        }
                    }
                    return lines.filter(l=>l.trim().length>0).join('\n');
                })(code);
                if (codeInput) {
                    codeInput.value = code || '// (empty)';

                    __lastGeneratedCode = codeInput.value;
                    __userEditedSinceSync = false;
                }
                return code;
            }

            // Remove existing event listeners to prevent duplicates
            runBtn.onclick = null;
            stopBtn.onclick = null;
            clearBtn.onclick = null;

            runBtn.addEventListener('click', (e)=>{
                console.log('Run button clicked');
                e.preventDefault();
                e.stopPropagation();
                if (!isRunning) {
                    runBtn.style.display = 'none';
                    stopBtn.style.display = 'block';
                    runCode();
                } else {
                    hynthera_output('⚠️ Code is already running!');
                }
            });

            // Code input is now self-contained with no highlighting overlay

            stopBtn.addEventListener('click', (e)=>{
                console.log('Stop button clicked');
                e.preventDefault();
                e.stopPropagation();
                shouldStop = true;
                isRunning = false;
                try { if (loopWorker) { loopWorker.postMessage({ type:'stop' }); } } catch(_){}
                runBtn.style.display = 'block';
                stopBtn.style.display = 'none';
                hynthera_output('🛑 Execution stopped by user');
            });

            clearBtn.addEventListener('click', (e)=>{
                console.log('Clear button clicked');
                e.preventDefault();
                e.stopPropagation();
                clearOutput();
            });

            if (refreshBtn) {
                refreshBtn.addEventListener('click', ()=>{
                    location.reload(true); // Force reload
                });
            }
        });
        const darkTheme = Blockly.Theme.defineTheme('darkMode', {
            'base': Blockly.Themes.Dark,
            'componentStyles': {
                'workspaceBackground': '#0d1117',
                'toolboxBackground': '#161b22',
                'toolboxForeground': '#f0f6fc',
                'flyoutBackground': '#21262d',
                'flyoutForeground': '#f0f6fc',
                'scrollbarColour': '#30363d',
                'insertionMarker': '#238636',
                'markerColour': '#f85149',
                'cursorColour': '#f0f6fc'
            },
            'blockStyles': {
                'logic_blocks': {
                    'colourPrimary': '#2f81f7',
                    'colourSecondary': '#1f6feb',
                    'colourTertiary': '#0969da'
                },
                'loop_blocks': {
                    'colourPrimary': '#2ea043',
                    'colourSecondary': '#238636',
                    'colourTertiary': '#1a7f37'
                },
                'math_blocks': {
                    'colourPrimary': '#8b5cf6',
                    'colourSecondary': '#7c3aed',
                    'colourTertiary': '#6d28d9'
                },
                'text_blocks': {
                    'colourPrimary': '#fb923c',
                    'colourSecondary': '#f97316',
                    'colourTertiary': '#ea580c'
                },
                'variable_blocks': {
                    'colourPrimary': '#f472b6',
                    'colourSecondary': '#ec4899',
                    'colourTertiary': '#db2777'
                },
                'procedure_blocks': {
                    'colourPrimary': '#a855f7',
                    'colourSecondary': '#9333ea',
                    'colourTertiary': '#7c2d12'
                },
                'roblox_blocks': {
                    'colourPrimary': '#00d4aa',
                    'colourSecondary': '#00b894',
                    'colourTertiary': '#00a085'
                },
                'event_blocks': {
                    'colourPrimary': '#fbbf24',
                    'colourSecondary': '#f59e0b',
                    'colourTertiary': '#d97706'
                }
            }
        });

        // Define custom blocks BEFORE creating workspace
        // Define Event Blocks
        Blockly.Blocks['when_start_clicked'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("🚩 when start clicked");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour('#ffab19');
                this.setTooltip("Runs when the start button is clicked");
            }
        };

        Blockly.JavaScript['when_start_clicked'] = function(block) {
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return '// Event: when start clicked\n' + statements;
        };

        // Output Blocks
    Blockly.Blocks['print_output'] = {
            init: function() {
                this.appendValueInput("TEXT")
                    .setCheck(null)
            .appendField("print");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#fd79a8');
                this.setTooltip("Print text to the console");
            }
        };

        Blockly.JavaScript['print_output'] = function(block) {
            var text = Blockly.JavaScript.valueToCode(block, 'TEXT', Blockly.JavaScript.ORDER_ATOMIC) || '""';
                return 'print(' + text + ');\n';
        };

    Blockly.Blocks['warn_output'] = {
            init: function() {
                this.appendValueInput("TEXT")
                    .setCheck(null)
            .appendField("warn");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#fd79a8');
                this.setTooltip("Print a warning to the console");
            }
        };

        Blockly.JavaScript['warn_output'] = function(block) {
            var text = Blockly.JavaScript.valueToCode(block, 'TEXT', Blockly.JavaScript.ORDER_ATOMIC) || '""';
        return 'warn(' + text + ');\n';
        };

        // Simple comment statement block
        Blockly.Blocks['comment'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField('💬')
                    .appendField(new Blockly.FieldTextInput('comment'), 'TEXT');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#656d76');
                this.setTooltip('Comment (no execution)');
            }
        };
        Blockly.JavaScript['comment'] = function(block) {
            var t = block.getFieldValue('TEXT') || '';
            return '// ' + t + '\n';
        };

        // Roblox API Blocks - MOVED HERE TO BE DEFINED BEFORE WORKSPACE CREATION
        
        // Get Game Service Block
        Blockly.Blocks['get_service'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("🎮 get service")
                    .appendField(new Blockly.FieldDropdown([
                        ["Workspace", "Workspace"],
                        ["Players", "Players"],
                        ["Lighting", "Lighting"],
                        ["ReplicatedStorage", "ReplicatedStorage"],
                        ["StarterGui", "StarterGui"],
                        ["StarterPack", "StarterPack"],
                        ["StarterPlayer", "StarterPlayer"],
                        ["TweenService", "TweenService"],
                        ["RunService", "RunService"],
                        ["UserInputService", "UserInputService"]
                    ]), "SERVICE");
                this.setOutput(true, "Instance");
                this.setColour('#00d4aa');
                this.setTooltip("Get a Roblox service");
            }
        };

        Blockly.JavaScript['get_service'] = function(block) {
            var service = block.getFieldValue('SERVICE');
            return ['await RobloxAPI.getService("' + service + '")', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Find First Child Block
        Blockly.Blocks['find_first_child'] = {
            init: function() {
                this.appendValueInput("PARENT")
                    .setCheck("Instance")
                    .appendField("🔍 find first child");
                this.appendValueInput("NAME")
                    .setCheck("String")
                    .appendField("named");
                this.setOutput(true, "Instance");
                this.setColour('#00d4aa');
                this.setTooltip("Find first child by name");
            }
        };

        Blockly.JavaScript['find_first_child'] = function(block) {
            var parent = Blockly.JavaScript.valueToCode(block, 'PARENT', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            var name = Blockly.JavaScript.valueToCode(block, 'NAME', Blockly.JavaScript.ORDER_ATOMIC) || '""';
            return ['await RobloxAPI.findFirstChild(' + parent + ', ' + name + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Find First Child of Class Block
        Blockly.Blocks['find_first_child_of_class'] = {
            init: function() {
                this.appendValueInput("PARENT")
                    .setCheck("Instance")
                    .appendField("🔍 find first child of class");
                this.appendValueInput("CLASS")
                    .setCheck("String")
                    .appendField("class");
                this.setOutput(true, "Instance");
                this.setColour('#00d4aa');
                this.setTooltip("Find first child by class name");
            }
        };

        Blockly.JavaScript['find_first_child_of_class'] = function(block) {
            var parent = Blockly.JavaScript.valueToCode(block, 'PARENT', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            var className = Blockly.JavaScript.valueToCode(block, 'CLASS', Blockly.JavaScript.ORDER_ATOMIC) || '""';
            return ['await RobloxAPI.findFirstChildOfClass(' + parent + ', ' + className + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Get Children Block
        Blockly.Blocks['get_children'] = {
            init: function() {
                this.appendValueInput("PARENT")
                    .setCheck("Instance")
                    .appendField("📦 get children of");
                this.setOutput(true, "Array");
                this.setColour('#00d4aa');
                this.setTooltip("Get all children of an instance");
            }
        };

        Blockly.JavaScript['get_children'] = function(block) {
            var parent = Blockly.JavaScript.valueToCode(block, 'PARENT', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            return ['await RobloxAPI.getChildren(' + parent + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Get Descendants Block
        Blockly.Blocks['get_descendants'] = {
            init: function() {
                this.appendValueInput("PARENT")
                    .setCheck("Instance")
                    .appendField("🌲 get descendants of");
                this.setOutput(true, "Array");
                this.setColour('#00d4aa');
                this.setTooltip("Get all descendants of an instance");
            }
        };

        Blockly.JavaScript['get_descendants'] = function(block) {
            var parent = Blockly.JavaScript.valueToCode(block, 'PARENT', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            return ['await RobloxAPI.getDescendants(' + parent + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Get Instance Name Block
        Blockly.Blocks['get_instance_name'] = {
            init: function() {
                this.appendValueInput("INSTANCE")
                    .setCheck("Instance")
                    .appendField("🏷️ name of");
                this.setOutput(true, "String");
                this.setColour('#00d4aa');
                this.setTooltip("Get the name of an instance");
            }
        };

        Blockly.JavaScript['get_instance_name'] = function(block) {
            var instance = Blockly.JavaScript.valueToCode(block, 'INSTANCE', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            return ['await RobloxAPI.getName(' + instance + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Get Instance Class Block
        Blockly.Blocks['get_instance_class'] = {
            init: function() {
                this.appendValueInput("INSTANCE")
                    .setCheck("Instance")
                    .appendField("🏗️ class of");
                this.setOutput(true, "String");
                this.setColour('#00d4aa');
                this.setTooltip("Get the class name of an instance");
            }
        };

        Blockly.JavaScript['get_instance_class'] = function(block) {
            var instance = Blockly.JavaScript.valueToCode(block, 'INSTANCE', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            return ['await RobloxAPI.getClass(' + instance + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Get Local Player Block
        Blockly.Blocks['get_local_player'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("👤 local player");
                this.setOutput(true, "Instance");
                this.setColour('#00d4aa');
                this.setTooltip("Get the local player");
            }
        };

        Blockly.JavaScript['get_local_player'] = function(block) {
            return ['await RobloxAPI.getLocalPlayer()', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Get Player Character Block
        Blockly.Blocks['get_character'] = {
            init: function() {
                this.appendValueInput("PLAYER")
                    .setCheck("Instance")
                    .appendField("🚶 character of");
                this.setOutput(true, "Instance");
                this.setColour('#00d4aa');
                this.setTooltip("Get the character of a player");
            }
        };

        Blockly.JavaScript['get_character'] = function(block) {
            var player = Blockly.JavaScript.valueToCode(block, 'PLAYER', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            return ['await RobloxAPI.getCharacter(' + player + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Get Position Block
        Blockly.Blocks['get_position'] = {
            init: function() {
                this.appendValueInput("INSTANCE")
                    .setCheck("Instance")
                    .appendField("📍 position of");
                this.setOutput(true, "Vector3");
                this.setColour('#00d4aa');
                this.setTooltip("Get the position of an instance");
            }
        };

        Blockly.JavaScript['get_position'] = function(block) {
            var instance = Blockly.JavaScript.valueToCode(block, 'INSTANCE', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            return ['await RobloxAPI.getPosition(' + instance + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Set Position Block
        Blockly.Blocks['set_position'] = {
            init: function() {
                this.appendValueInput("INSTANCE")
                    .setCheck("Instance")
                    .appendField("📍 set position of");
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField("to X:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField("Y:");
                this.appendValueInput("Z")
                    .setCheck("Number")
                    .appendField("Z:");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#00d4aa');
                this.setTooltip("Set the position of an instance");
            }
        };

        Blockly.JavaScript['set_position'] = function(block) {
            var instance = Blockly.JavaScript.valueToCode(block, 'INSTANCE', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            var x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            var y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            var z = Blockly.JavaScript.valueToCode(block, 'Z', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            return 'await RobloxAPI.setPosition(' + instance + ', ' + x + ', ' + y + ', ' + z + ');\n';
        };

        // Get Health Block
        Blockly.Blocks['get_health'] = {
            init: function() {
                this.appendValueInput("HUMANOID")
                    .setCheck("Instance")
                    .appendField("❤️ health of");
                this.setOutput(true, "Number");
                this.setColour('#00d4aa');
                this.setTooltip("Get the health of a humanoid");
            }
        };

        Blockly.JavaScript['get_health'] = function(block) {
            var humanoid = Blockly.JavaScript.valueToCode(block, 'HUMANOID', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            return ['await RobloxAPI.getHealth(' + humanoid + ')', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // Set WalkSpeed Block
        Blockly.Blocks['set_walkspeed'] = {
            init: function() {
                this.appendValueInput("HUMANOID")
                    .setCheck("Instance")
                    .appendField("🏃 set walkspeed of");
                this.appendValueInput("SPEED")
                    .setCheck("Number")
                    .appendField("to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#00d4aa');
                this.setTooltip("Set the walkspeed of a humanoid");
            }
        };

        Blockly.JavaScript['set_walkspeed'] = function(block) {
            var humanoid = Blockly.JavaScript.valueToCode(block, 'HUMANOID', Blockly.JavaScript.ORDER_ATOMIC) || 'null';
            var speed = Blockly.JavaScript.valueToCode(block, 'SPEED', Blockly.JavaScript.ORDER_ATOMIC) || '16';
            return 'await RobloxAPI.setWalkSpeed(' + humanoid + ', ' + speed + ');\n';
        };

        console.log('✅ All Roblox API blocks have been defined!');

        const workspace = Blockly.inject('blocklyDiv', {
            toolbox: `
            <xml xmlns="https://developers.google.com/blockly/xml" id="toolbox" style="display: none">
                <category name="🚩 Events" colour="#fbbf24">
                    <block type="when_start_clicked"></block>
                </category>
                <category name="🎮 Roblox API" colour="#00d4aa">
                    <block type="get_service">
                        <field name="SERVICE">Workspace</field>
                    </block>
                    <block type="get_service">
                        <field name="SERVICE">Players</field>
                    </block>
                    <block type="get_local_player"></block>
                    <block type="get_character">
                        <value name="PLAYER">
                            <block type="get_local_player"></block>
                        </value>
                    </block>
                    <block type="find_first_child">
                        <value name="PARENT">
                            <block type="get_service">
                                <field name="SERVICE">Workspace</field>
                            </block>
                        </value>
                        <value name="NAME">
                            <block type="text">
                                <field name="TEXT">Baseplate</field>
                            </block>
                        </value>
                    </block>
                    <block type="find_first_child_of_class">
                        <value name="PARENT">
                            <block type="get_service">
                                <field name="SERVICE">Workspace</field>
                            </block>
                        </value>
                        <value name="CLASS">
                            <block type="text">
                                <field name="TEXT">Model</field>
                            </block>
                        </value>
                    </block>
                    <block type="get_children"></block>
                    <block type="get_descendants"></block>
                    <block type="get_instance_name"></block>
                    <block type="get_instance_class"></block>
                    <block type="get_position"></block>
                    <block type="set_position">
                        <value name="X">
                            <block type="math_number">
                                <field name="NUM">0</field>
                            </block>
                        </value>
                        <value name="Y">
                            <block type="math_number">
                                <field name="NUM">5</field>
                            </block>
                        </value>
                        <value name="Z">
                            <block type="math_number">
                                <field name="NUM">0</field>
                            </block>
                        </value>
                    </block>
                    <block type="get_health"></block>
                    <block type="set_walkspeed">
                        <value name="SPEED">
                            <block type="math_number">
                                <field name="NUM">50</field>
                            </block>
                        </value>
                    </block>
                </category>
                <category name="🔧 Logic" colour="#2f81f7">
                    <block type="controls_if"></block>
                    <block type="logic_compare"></block>
                    <block type="logic_operation"></block>
                    <block type="logic_negate"></block>
                    <block type="logic_boolean"></block>
                </category>
                <category name="🔁 Loops" colour="#2ea043">
                    <block type="controls_repeat_ext"></block>
                    <block type="controls_whileUntil"></block>
                    <block type="controls_for"></block>
                    <block type="controls_forEach"></block>
                    <block type="wait_seconds">
                        <value name="SECONDS">
                            <block type="math_number">
                                <field name="NUM">1</field>
                            </block>
                        </value>
                    </block>
                </category>
                <category name="🔢 Math" colour="#8b5cf6">
                    <block type="math_number"></block>
                    <block type="math_arithmetic"></block>
                    <block type="math_single"></block>
                    <block type="math_round"></block>
                    <block type="math_random_int"></block>
                </category>
                <category name="📝 Text" colour="#fb923c">
                    <block type="text"></block>
                    <block type="text_join"></block>
                    <block type="text_append"></block>
                    <block type="text_length"></block>
                </category>
                <category name="📦 Variables" colour="#f472b6" custom="VARIABLE"></category>
                <category name="⚙️ Functions" colour="#a855f7" custom="PROCEDURE"></category>
                <category name="💬 Output" colour="#fd79a8">
                    <block type="print_output"></block>
                    <block type="warn_output"></block>
                    <block type="comment"></block>
                </category>
            </xml>
            `,
            theme: darkTheme,
            grid: {
                spacing: 25,
                length: 1,
                colour: 'rgba(255,255,255,0.08)',
                snap: true
            },
            zoom: {
                controls: true,
                wheel: true,
                startScale: 0.9,
                maxScale: 2.5,
                minScale: 0.4,
                scaleSpeed: 1.1
            },
            sounds: false
        });

        // Global variables for script execution
        let isRunning = false;
        let shouldStop = false;
    let loopWorker = null; // Web Worker for high-FPS loop execution
    let __ROBLOX_DEBUG = true; // Enable verbose Roblox API call logging by default (user can set to false in console)

        // Define Event Blocks BEFORE workspace creation
        Blockly.Blocks['when_start_clicked'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("🚩 when start clicked");
                this.appendStatementInput("DO")
                    .setCheck(null);
                this.setColour('#ffab19');
                this.setTooltip("Runs when the start button is clicked");
            }
        };

        Blockly.JavaScript['when_start_clicked'] = function(block) {
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return '// Event: when start clicked\n' + statements;
        };

        // Override Blockly's loop generators to be async-friendly
        Blockly.JavaScript['controls_repeat_ext'] = function(block) {
            var repeats = Blockly.JavaScript.valueToCode(block, 'TIMES', Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
            var branch = Blockly.JavaScript.statementToCode(block, 'DO');
            branch = Blockly.JavaScript.addLoopTrap(branch, block);
            var code = '';
            var loopVar = Blockly.JavaScript.variableDB_.getDistinctName('count', Blockly.VARIABLE_CATEGORY_NAME);
            var endVar = repeats;
            if (!repeats.match(/^\w+$/) && !Blockly.isNumber(repeats)) {
                endVar = Blockly.JavaScript.variableDB_.getDistinctName('repeat_end', Blockly.VARIABLE_CATEGORY_NAME);
                code += 'var ' + endVar + ' = ' + repeats + ';\n';
            }
            code += 'for (var ' + loopVar + ' = 0; ' +
                loopVar + ' < ' + endVar + '; ' +
                loopVar + '++) {\n' +
                branch + '}\n';
            return code;
        };

        Blockly.JavaScript['controls_whileUntil'] = function(block) {
            var until = block.getFieldValue('MODE') == 'UNTIL';
            var argument0 = Blockly.JavaScript.valueToCode(block, 'BOOL',
                until ? Blockly.JavaScript.ORDER_LOGICAL_NOT :
                Blockly.JavaScript.ORDER_NONE) || 'false';
            var branch = Blockly.JavaScript.statementToCode(block, 'DO');
            branch = Blockly.JavaScript.addLoopTrap(branch, block);
            if (until) {
                argument0 = '!' + argument0;
            }
            return 'while (' + argument0 + ') {\n' + branch + '}\n';
        };

        Blockly.JavaScript['controls_for'] = function(block) {
            var variable0 = Blockly.JavaScript.variableDB_.getName(
                block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
            var argument0 = Blockly.JavaScript.valueToCode(block, 'FROM',
                Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
            var argument1 = Blockly.JavaScript.valueToCode(block, 'TO',
                Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
            var increment = Blockly.JavaScript.valueToCode(block, 'BY',
                Blockly.JavaScript.ORDER_ASSIGNMENT) || '1';
            var branch = Blockly.JavaScript.statementToCode(block, 'DO');
            branch = Blockly.JavaScript.addLoopTrap(branch, block);
            var code;
            if (Blockly.isNumber(argument0) && Blockly.isNumber(argument1) &&
                Blockly.isNumber(increment)) {
                var up = parseFloat(argument0) <= parseFloat(argument1);
                code = 'for (' + variable0 + ' = ' + argument0 + '; ' +
                    variable0 + (up ? ' <= ' : ' >= ') + argument1 + '; ' +
                    variable0;
                var step = Math.abs(parseFloat(increment));
                if (step == 1) {
                    code += up ? '++' : '--';
                } else {
                    code += (up ? ' += ' : ' -= ') + step;
                }
                code += ') {\n' + branch + '}\n';
            } else {
                code = '';
                var incVar = Blockly.JavaScript.variableDB_.getDistinctName(
                    variable0 + '_inc', Blockly.VARIABLE_CATEGORY_NAME);
                code += 'var ' + incVar + ' = ' + increment + ';\n';
                code += 'if (' + incVar + ' > 0) {\n';
                code += Blockly.JavaScript.INDENT + 'for (' + variable0 + ' = ' + argument0 + '; ' +
                    variable0 + ' <= ' + argument1 + '; ' + variable0 + ' += ' + incVar + ') {\n';
                code += branch;
                code += Blockly.JavaScript.INDENT + '}\n';
                code += '} else {\n';
                code += Blockly.JavaScript.INDENT + 'for (' + variable0 + ' = ' + argument0 + '; ' +
                    variable0 + ' >= ' + argument1 + '; ' + variable0 + ' += ' + incVar + ') {\n';
                code += branch;
                code += Blockly.JavaScript.INDENT + '}\n';
                code += '}\n';
            }
            return code;
        };

        // Output Blocks
    Blockly.Blocks['print_output'] = {
            init: function() {
                this.appendValueInput("TEXT")
                    .setCheck(null)
            .appendField("print");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#fd79a8');
                this.setTooltip("Print text to the console");
            }
        };

        Blockly.JavaScript['print_output'] = function(block) {
            var text = Blockly.JavaScript.valueToCode(block, 'TEXT', Blockly.JavaScript.ORDER_ATOMIC) || '""';
            return 'hynthera_output(' + text + ');\n';
        };

    Blockly.Blocks['warn_output'] = {
            init: function() {
                this.appendValueInput("TEXT")
                    .setCheck(null)
            .appendField("warn");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#fd79a8');
                this.setTooltip("Print a warning to the console");
            }
        };

        Blockly.JavaScript['warn_output'] = function(block) {
            var text = Blockly.JavaScript.valueToCode(block, 'TEXT', Blockly.JavaScript.ORDER_ATOMIC) || '""';
            return 'hynthera_output({message: ' + text + ', type: "warn"});\n';
        };

        // Generic expression statement wrapper so any value block can be chained
        Blockly.Blocks['expr_statement'] = {
            init: function() {
                this.appendValueInput('EXPR').setCheck(null).appendField('do');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#9ca3af');
                this.setTooltip('Execute an expression as a statement');
            }
        };
        Blockly.JavaScript['expr_statement'] = function(block) {
            var code = Blockly.JavaScript.valueToCode(block, 'EXPR', Blockly.JavaScript.ORDER_NONE) || '';
            if (!code) return ';// empty\n';
            // Ensure exactly one semicolon and newline at the end
            code = code.replace(/\s+$/, '');
            if (!/;\s*$/.test(code)) code += ';';
            return code + '\n';
        };

        // Wait/Delay Block
        Blockly.Blocks['wait_seconds'] = {
            init: function() {
                this.appendValueInput("SECONDS")
                    .setCheck("Number")
                    .appendField("⏱️ wait");
                this.appendDummyInput()
                    .appendField("seconds");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#40bf4a');
                this.setTooltip("Wait for a specified number of seconds (max 5 seconds)");
            }
        };

        Blockly.JavaScript['wait_seconds'] = function(block) {
            var seconds = Blockly.JavaScript.valueToCode(block, 'SECONDS', Blockly.JavaScript.ORDER_ATOMIC) || '1';
            // Limit wait time to max 5 seconds to prevent abuse
            return 'await new Promise(resolve => setTimeout(resolve, Math.min(' + seconds + ' * 1000, 5000)));\n';
        };

        // NOTE: Roblox API blocks have been moved above workspace creation

        const RobloxAPI = {
            game: null,
            workspace: null,
            players: null,
            isConnected: false,
            // Ensure we never send an empty object ("{}") to the backend.
            // Accept both instance objects and raw addresses (number) for convenience.
            sanitizeInstance(obj) {
                if (!obj) return null;
                // If already has an address property that's a number, return minimal shape.
                if (typeof obj === 'object') {
                    if (typeof obj.address === 'number') {
                        return { address: obj.address, className: obj.className || obj.class || obj.ClassName || '', name: obj.name || obj.Name || '' };
                    }
                    // Some blocks may store address under different casing
                    for (const key of Object.keys(obj)) {
                        if (/addr|address/i.test(key) && typeof obj[key] === 'number') {
                            return { address: obj[key], className: obj.className || '', name: obj.name || '' };
                        }
                    }
                    return null; // Object provided but no usable address
                }
                if (typeof obj === 'number') {
                    return { address: obj, className: '', name: '' };
                }
                return null;
            },
            
            async initialize() {
                try {
                    if (!window.chrome || !window.chrome.webview) {
                        throw new Error('WebView2 interface not available');
                    }
                    
                    const result = await this.callBackend('attach', {});
                    if (result.success) {
                        this.isConnected = true;
                        this.game = { address: result.dataModel, name: "Game", className: "DataModel" };
                        
                        this.workspace = await this.getService('Workspace');
                        this.players = await this.getService('Players');
                        return true;
                    } else {
                        throw new Error(result.error || 'Failed to attach to Roblox');
                    }
                } catch (error) {
                    console.error('RobloxAPI initialization failed:', error);
                    hynthera_output({message:'Failed to connect to Roblox: ' + error.message, type:'error'});
                    hynthera_output('💡 Make sure Roblox is running and you\'re in a game');
                    this.isConnected = false;
                    return false;
                }
            },

            async callBackend(functionName, params = {}) {
                if (!window.chrome || !window.chrome.webview) {
                    throw new Error('WebView2 interface not available');
                }

                return new Promise((resolve, reject) => {
                    const messageId = Math.random().toString(36).substring(7);
                    const message = JSON.stringify({
                        id: messageId,
                        function: functionName,
                        params: params
                    });

                    if (window.__ROBLOX_DEBUG) {
                        try { hynthera_output({ message: `➡️ ${functionName}(${Object.keys(params).map(k=>k+':' + JSON.stringify(params[k])).join(', ')})`, type: 'info'}); } catch(_) {}
                    }

                    const handleResponse = (event) => {
                        try {
                            const response = JSON.parse(event.data);
                            if (response.id === messageId) {
                                window.removeEventListener('message', handleResponse);
                                if (window.__ROBLOX_DEBUG) {
                                    if (response.success) {
                                        hynthera_output({ message: `✅ ${functionName} success`, type: 'info'});
                                    } else {
                                        hynthera_output({ message: `❌ ${functionName} failed: ${response.error || 'unknown error'}`, type: 'error'});
                                    }
                                }
                                resolve(response);
                            }
                        } catch (e) {
                        }
                    };

                    window.addEventListener('message', handleResponse);
                    window.chrome.webview.postMessage(message);

                    setTimeout(() => {
                        window.removeEventListener('message', handleResponse);
                        reject(new Error('Backend call timeout'));
                    }, 5000);
                });
            },

            async getService(serviceName) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return null;
                }
                
                const result = await this.callBackend('getService', { serviceName });
                if (result.success) return result.instance;
                hynthera_output(`❌ Failed to get service: ${serviceName}`);
                return null;
            },

            async findFirstChild(parent, name) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return null;
                }
                if (!parent) {
                    hynthera_output({message:'FindFirstChild: Invalid parent', type:'error'});
                    return null;
                }
                
                const result = await this.callBackend('findFirstChild', { parent, name });
                if (result.success && result.instance) return result.instance;
                hynthera_output({message:`Child "${name}" not found in ${parent.name || 'object'}`, type:'warn'});
                return null;
            },

            async findFirstChildOfClass(parent, className) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return null;
                }
                if (!parent) {
                    hynthera_output({message:'FindFirstChildOfClass: Invalid parent', type:'error'});
                    return null;
                }
                
                const result = await this.callBackend('findFirstChildOfClass', { parent, className });
                if (result.success && result.instance) return result.instance;
                hynthera_output({message:`No child of class "${className}" found in ${parent.name || 'object'}`, type:'warn'});
                return null;
            },

            async getChildren(parent) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return [];
                }
                parent = this.sanitizeInstance(parent);
                if (!parent) {
                    hynthera_output({message:'GetChildren: Invalid parent', type:'error'});
                    return [];
                }
                
                const result = await this.callBackend('getChildren', { parent });
                if (result.success) return result.children;
                return [];
            },

            async getDescendants(parent) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return [];
                }
                parent = this.sanitizeInstance(parent);
                if (!parent) {
                    hynthera_output({message:'GetDescendants: Invalid parent', type:'error'});
                    return [];
                }
                
                const result = await this.callBackend('getDescendants', { parent });
                if (result.success) return result.descendants;
                return [];
            },

            async getName(instance) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return '';
                }
                instance = this.sanitizeInstance(instance);
                if (!instance) {
                    hynthera_output({message:'GetName: Invalid instance', type:'error'});
                    return '';
                }
                
                const result = await this.callBackend('getName', { instance });
                return result.success ? result.name : '';
            },

            async getClass(instance) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return '';
                }
                instance = this.sanitizeInstance(instance);
                if (!instance) {
                    hynthera_output({message:'GetClass: Invalid instance', type:'error'});
                    return '';
                }
                
                const result = await this.callBackend('getClass', { instance });
                return result.success ? result.className : '';
            },

            async getLocalPlayer() {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return null;
                }
                
                const result = await this.callBackend('getLocalPlayer');
                if (result.success) return result.player;
                hynthera_output({message:'Failed to get local player: ' + (result.error || 'Unknown error'), type:'error'});
                return null;
            },

            async getCharacter(player) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return null;
                }
                if (!player) {
                    hynthera_output({message:'GetCharacter: Invalid player', type:'error'});
                    return null;
                }
                
                const result = await this.callBackend('getCharacter', { player });
                if (result.success) return result.character;
                return null;
            },

            async getPosition(instance) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return { x: 0, y: 0, z: 0 };
                }
                if (!instance) {
                    hynthera_output({message:'GetPosition: Invalid instance', type:'error'});
                    return { x: 0, y: 0, z: 0 };
                }
                
                const result = await this.callBackend('getPosition', { instance });
                if (result.success) return result.position;
                return { x: 0, y: 0, z: 0 };
            },

            async setPosition(instance, x, y, z) {
                if (!this.isConnected) {
                    hynthera_output({message:'Not connected to Roblox', type:'error'});
                    return;
                }
                if (!instance) {
                    hynthera_output('❌ SetPosition: Invalid instance');
                    return;
                }
                
                await this.callBackend('setPosition', { instance, x, y, z });
            },

            async getHealth(humanoid) {
                if (!this.isConnected) {
                    hynthera_output('❌ Not connected to Roblox');
                    return 0;
                }
                if (!humanoid) {
                    hynthera_output('❌ GetHealth: Invalid humanoid');
                    return 0;
                }
                
                const result = await this.callBackend('getHealth', { humanoid });
                if (result.success) return result.health;
                return 0;
            },

            async setWalkSpeed(humanoid, speed) {
                if (!this.isConnected) {
                    hynthera_output('❌ Not connected to Roblox');
                    return;
                }
                if (!humanoid) {
                    hynthera_output('❌ SetWalkSpeed: Invalid humanoid');
                    return;
                }
                
                await this.callBackend('setWalkSpeed', { humanoid, speed });
            }
        };

        document.addEventListener('DOMContentLoaded', async function() {
            setTimeout(async () => {
                await RobloxAPI.initialize();
            }, 1000);
        });

        // Receive logs from native (C++) via WebView2 PostWebMessageAsString
        if (window.chrome && window.chrome.webview) {
            try {
                window.chrome.webview.addEventListener('message', (e) => {
                    const data = e && e.data ? e.data : '';
                    // Accept either plain strings or JSON {message,type}
                    try {
                        const obj = JSON.parse(data);
                        // Suppress silent backend response logs for saves (user doesn't need to see them)
                        if (obj && obj.path && obj.success && /ProgramData\/.+\.json$/i.test(obj.path) && !obj.error) {
                            return; // ignore saveProgram success response
                        }
                        // Also ignore generic dispatcher ACKs with only id/success
                        if (obj && obj.success && Object.keys(obj).every(k=>['id','success'].includes(k))) {
                            return;
                        }
                        hynthera_output(obj);
                    } catch(_) {
                        hynthera_output(String(data));
                    }
                });
            } catch(_) {}
        }

        // Output functions (colored, structured, no emojis)
    function print(entry) { return hynthera_output(entry); }
    function warn(entry) { return hynthera_output({message: entry, type:'warn'}); }
    function hynthera_output(entry) {
            const output = document.getElementById('output');
            if (!output) return;

            // Normalize entry into object {message, type}
            let obj;
            // If a Promise is passed directly, resolve it asynchronously and print the result
            if (entry && typeof entry.then === 'function') {
                (async () => {
                    try {
                        const v = await entry;
                        hynthera_output(v);
                    } catch (e) {
                        hynthera_output({message: String(e && e.message ? e.message : e), type:'error'});
                    }
                })();
                return;
            }
            if (typeof entry === 'string') {
                obj = { message: entry, type: 'info' };
            } else if (entry && typeof entry === 'object') {
                obj = { message: entry.message || JSON.stringify(entry), type: entry.type || entry.__type || 'info' };
            } else {
                obj = { message: String(entry), type: 'info' };
            }

            // Infer type from prefixes if present
            if (/^warn[:\]]/i.test(obj.message) || obj.message.startsWith('WARN ')) obj.type = 'warn';
            if (/^error[:\]]/i.test(obj.message) || obj.message.startsWith('ERROR ')) obj.type = 'error';

            const timestamp = new Date().toLocaleTimeString();
            const line = document.createElement('div');
            line.style.padding = '0';
            line.style.margin = '0';
            line.style.fontFamily = 'Consolas,monospace';
            line.style.fontSize = '11px';

            // Color mapping
            let color = '#7ee787'; // info (muted green)
            if (obj.type === 'warn') color = '#e3b341'; // dim yellow
            else if (obj.type === 'error') color = '#f85149'; // red
            line.style.color = color;

            // Keep emojis (like checkmarks) intact; only trim whitespace
            obj.message = String(obj.message || '').trim();
            if (/await is only valid in async functions/i.test(obj.message)) {
                obj.type = 'error';
                obj.message += ' — wrapped code with async automatically. If you pasted raw JS, keep it as-is.';
            }
            if (!obj.message) obj.message = '.'; // ensure something visible

            line.textContent = `[${timestamp}] ${obj.type.toUpperCase()}: ${obj.message}`;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            const output = document.getElementById('output');
            const codeInput = document.getElementById('codeInput');
            if (output) {
                output.innerHTML = '';
                const init = document.createElement('div');
                init.style.color = '#7ee787';
                init.textContent = '// Output will appear here';
                output.appendChild(init);
            }
            // Don't nuke user code; only reset if we know it was our generated snapshot
            if (codeInput && codeInput.value === __lastGeneratedCode) {
                codeInput.value = '// Generated code will appear here';
                __userEditedSinceSync = false;
            }
        }

    // Two-way sync support (lightweight)
        // We only annotate each top-level stack with a position comment preceding its generated code:
        // // BLOCK_POS:x,y
        // <generated js...>
        // When user edits/pastes code, we reconstruct simple print / warn stacks and place them.
    let __isUpdatingCode = false;
    let __codeLoadDebounce = null;
    let __userEditedSinceSync = false; // true when textarea changed but we didn't fully rebuild blocks
    let __lastGeneratedCode = '';      // snapshot of the last code produced from blocks

        function generateCodeWithPositions() {
            try {
                const topBlocks = workspace.getTopBlocks(true);
                if (topBlocks.length === 0) {
                    return '// No blocks in workspace\n';
                }
                
                let pieces = [];
                // Initialize generator to ensure nameDB and variables are prepared
                Blockly.JavaScript.init(workspace);
                
                topBlocks.forEach(tb => {
                    if (!tb) return;
                    
                    try {
                        const xy = tb.getRelativeToSurfaceXY();
                        let code = Blockly.JavaScript.blockToCode(tb) || '';
                        
                        // Handle array return from blockToCode
                        if (Array.isArray(code)) code = code[0] || '';
                        
                        // Clean up the code
                        code = code.trimEnd();
                        if (code) {
                            pieces.push(`// BLOCK_POS:${xy.x},${xy.y}`);
                            pieces.push(code);
                        }
                    } catch (error) {
                        console.warn('Error generating code for block:', tb.type, error);
                        pieces.push('// Error generating code for block: ' + tb.type);
                    }
                });
                
                const full = pieces.join('\n');
                // Finish to allow Blockly to reset internal state
                const result = Blockly.JavaScript.finish(full);
                return result || '// Generated code is empty\n';
            } catch (error) {
                console.error('Error in generateCodeWithPositions:', error);
                return '// Error generating code: ' + error.message + '\n';
            }
        }

    function showCode() {
            try {
                const el = document.getElementById('codeInput');
                if (!el) {
                    console.warn('Code input element not found');
                    return;
                }
                
        if (document.activeElement === el || __userEditedSinceSync) {
                    return;
                }
                
                __isUpdatingCode = true;
        const newCode = serializeWorkspaceColumns();
                
                // Only update if code actually changed to prevent unnecessary updates
                if (newCode !== __lastGeneratedCode) {
                    __lastGeneratedCode = newCode;
                    el.value = newCode;
                    
                    // Update syntax highlighting if available
                    const high = document.getElementById('codeHighlight');
                    if (high) {
                        try { 
                            high.textContent = newCode; 
                            if (window.hljs && typeof hljs.highlightElement === 'function') {
                                hljs.highlightElement(high); 
                            }
                        } catch(highlightError) {
                            console.warn('Syntax highlighting error:', highlightError);
                        }
                    }
                }
            } catch (error) {
                console.error('Error in showCode:', error);
                const el = document.getElementById('codeInput');
                if (el && document.activeElement !== el) {
                    const errorMsg = '// Error generating code: ' + error.message + '\n// Please check the console for details\n';
                    el.value = errorMsg;
                    __lastGeneratedCode = errorMsg;
                    
                    const high = document.getElementById('codeHighlight');
                    if (high) { 
                        try { 
                            high.textContent = errorMsg; 
                        } catch(_){} 
                    }
                }
            } finally {
                __isUpdatingCode = false;
            }
        }

        function loadWorkspaceFromCode(codeText) {
            if (!codeText) return false;
            
            try {
                // Use the new robust parser
                const parser = new BlocklyCodeParser(workspace);
                const success = parser.parseAndLoad(codeText);
                
                if (success) {
                    // Sync the code textarea after successful parsing
                    __userEditedSinceSync = false;
                    showCode();
                    console.log('✅ Successfully loaded blocks from code');
                } else {
                    console.log('⚠️ No relevant blocks found in code');
                }
                
                return success;
            } catch (error) {
                console.error('❌ Error loading workspace from code:', error);
                hynthera_output({
                    message: 'Failed to parse code: ' + error.message, 
                    type: 'error'
                });
                return false;
            }
        }

    async function runCode() {
            // High-level execution strategy:
            // 1. Generate JS from blocks.
            // 2. If code contains loops (while/for) we prefer running inside a dedicated Web Worker (loop_worker.js)
            //    to achieve ~120 FPS yielding without blocking UI and still proxy RobloxAPI calls back to main thread.
            // 3. The worker injects await __checkContinue(); into loops and enforces iteration / time caps.
            // 4. If worker creation fails (e.g., CSP or environment limitation), fallback to inline execution with dynamic FPS.
            if (isRunning) return;
            const topBlocks = workspace.getTopBlocks(false);
            if (!topBlocks.length) { return; }
            let code = Blockly.JavaScript ? Blockly.JavaScript.workspaceToCode(workspace) : '';
            if (!code.trim()) { return; }

            // Decide whether to offload to worker (contains while/for loops or explicit request)
            const hasLoop = /(while\s*\(|for\s*\()/i.test(code);
            const canUseWorker = (typeof Worker !== 'undefined');
            if (hasLoop && canUseWorker) {
                // Start / re-use worker
                if (!loopWorker) {
                    try {
                        loopWorker = new Worker('loop_worker.js');
                        loopWorker.onmessage = async (e) => {
                            const msg = e.data || {};
                            if (msg.type === 'log') {
                                hynthera_output(msg.entry);
                            } else if (msg.type === 'finished') {
                                isRunning = false; shouldStop = false;
                                const runBtn = document.getElementById('runBtn');
                                const stopBtn = document.getElementById('stopBtn');
                                if (runBtn && stopBtn) { runBtn.style.display='block'; stopBtn.style.display='none'; }
                            } else if (msg.type === 'backendCall') {
                                // Proxy Roblox API calls from worker to real RobloxAPI
                                const { id, fn, args } = msg;
                                (async () => {
                                    let result, success = true, error = null;
                                    try {
                                        if (RobloxAPI[fn]) {
                                            result = await RobloxAPI[fn](... (Array.isArray(args) ? args : []));
                                        } else {
                                            throw new Error('Unknown RobloxAPI function: ' + fn);
                                        }
                                    } catch (err) {
                                        success = false; error = err.message;
                                    }
                                    try { loopWorker && loopWorker.postMessage({ type:'backendResult', id, success, result, error }); } catch(_){}
                                })();
                            }
                        };
                    } catch (err) {
                        console.warn('Worker creation failed, falling back to inline execution:', err);
                        loopWorker = null;
                    }
                }
            }

            isRunning = true; shouldStop = false;
            if (loopWorker) {
                const runBtn = document.getElementById('runBtn');
                const stopBtn = document.getElementById('stopBtn');
                if (runBtn && stopBtn) { runBtn.style.display='none'; stopBtn.style.display='block'; }
                loopWorker.postMessage({ type:'run', code });
            } else {
                // Fallback: inline execution (60->120 fps improved below)
                try {
                    const needsIIFE = !/(async\s*function|\(async\s*\()/ .test(code);
                    const wrapped = needsIIFE ? `(async()=>{\n${code}\n})()` : code;
                    await executeCodeSafely(wrapped, 120); // request 120 fps
                } catch (error) {
                    console.error('Blockly execution error:', error);
                } finally {
                    isRunning = false;
                    const runBtn = document.getElementById('runBtn');
                    const stopBtn = document.getElementById('stopBtn');
                    if (runBtn && stopBtn) { runBtn.style.display='block'; stopBtn.style.display='none'; }
                }
            }
        }

        // Simplified loop transformation: inject await checkContinue() at start of each loop body
        function transformLoopsToAsync(code){
            return code
                // for (...) {
                .replace(/for\s*\([^)]*\)\s*\{/g, m=> m + "\n    await checkContinue();")
                // while (...) {
                .replace(/while\s*\([^)]*\)\s*\{/g, m=> m + "\n    await checkContinue();");
        }

        async function executeCodeSafely(code, targetFps = 60) {
            shouldStop = false; // Reset stop flag
            const fps = Math.min(Math.max(targetFps, 1), 240); // clamp 1-240
            // Maximum execution time and frame rate settings
            const MAX_EXECUTION_TIME = 10000; // 10 seconds max
            const FRAME_DELAY = Math.floor(1000 / fps); // dynamic FPS
            
            // Transform loops to be async and non-blocking
            let safeCode = transformLoopsToAsync(code);

            // Preprocess: upgrade functions that use 'await' to async automatically
            function fixAwaitInFunctions(src) {
                try {
                    // function name(...) { ... }
                    src = src.replace(/function\s+([A-Za-z_$][\w$]*)\s*\(([^)]*)\)\s*\{([\s\S]*?)\}/g, (m, name, args, body) => {
                        if (/\bawait\b/.test(body) && !/^\s*async\b/.test(m)) {
                            return `async function ${name}(${args}){${body}}`;
                        }
                        return m;
                    });
                    // const/let/var fn = function(...) { ... }
                    src = src.replace(/(const|let|var)\s+([A-Za-z_$][\w$]*)\s*=\s*function\s*\(([^)]*)\)\s*\{([\s\S]*?)\}/g,
                        (m, decl, name, args, body) => {
                            if (/\bawait\b/.test(body) && !/async\s*function/.test(m)) {
                                return `${decl} ${name} = async function(${args}){${body}}`;
                            }
                            return m;
                        }
                    );
                    // const/let/var fn = (...) => { ... }
                    src = src.replace(/(const|let|var)\s+([A-Za-z_$][\w$]*)\s*=\s*\(([^)]*)\)\s*=>\s*\{([\s\S]*?)\}/g,
                        (m, decl, name, args, body) => {
                            if (/\bawait\b/.test(body) && !/^\s*async\s*\(/.test(m)) {
                                return `${decl} ${name} = async (${args}) => {${body}}`;
                            }
                            return m;
                        }
                    );
                } catch (_) {}
                return src;
            }
            safeCode = fixAwaitInFunctions(safeCode);
            
            const executeWithTiming = `
                (async function() {
                    let iterationCount = 0;
                    const maxIterations = 10000; // Prevent infinite loops
                    
                    // Helper function to check if we should continue and add frame delay
                    window.checkContinue = async function() {
                        iterationCount++;
                        
                        // Stop execution if requested
                        if (shouldStop) {
                            throw new Error('Execution stopped by user');
                        }
                        
                        // Prevent infinite loops
                        if (iterationCount > maxIterations) {
                            throw new Error('Maximum iterations exceeded - possible infinite loop detected');
                        }
                        
                        // Yield control to prevent freezing - dynamic FPS timing
                        await new Promise(resolve => setTimeout(resolve, ${FRAME_DELAY}));
                        return true;
                    };
                    
                    try {
                        ${safeCode}
                        if (!shouldStop) {
                            // silent success
                        }
                    } catch (e) {
                        hynthera_output({message:'Error: ' + e.message, type:'error'});
                        throw e;
                    }
                })();
            `;
            
            // Create execution timeout
            const startTime = Date.now();
            
            // Set up execution timeout
            const timeoutId = setTimeout(() => {
                if (!shouldStop) {
                    shouldStop = true;
                    hynthera_output({message:'Execution timeout - code took longer than 10 seconds', type:'error'});
                }
            }, MAX_EXECUTION_TIME);

            try {
                // Execute the transformed code in a controlled environment
                await eval(executeWithTiming);
                
            } catch (error) {
                if (!shouldStop) {
                    hynthera_output({message:'Execution error: ' + error.message, type:'error'});
                }
                console.error('Code execution error:', error);
                
            } finally {
                // Clean up timeout
                clearTimeout(timeoutId);
                
                // Clean up global helper function
                if (window.checkContinue) {
                    delete window.checkContinue;
                }
                
                // silent success end
            }
        }

        // Auto-update code preview (display only, don't execute)
        workspace.addChangeListener(function(event) {
            if (!isRunning && (event.type === Blockly.Events.BLOCK_MOVE || 
                event.type === Blockly.Events.BLOCK_CREATE || 
                event.type === Blockly.Events.BLOCK_DELETE ||
                event.type === Blockly.Events.BLOCK_CHANGE)) {
                showCode();
            }
        });

    const codeEl = document.getElementById('codeInput');
        if (codeEl) {
            const scheduleParse = () => {
                if (__isUpdatingCode) return;
                if (__codeLoadDebounce) clearTimeout(__codeLoadDebounce);
                __codeLoadDebounce = setTimeout(()=> {
                    const txt = codeEl.value || '';
                    if (!txt.trim()) {
                        try { workspace.clear(); } catch(_) {}
                        __userEditedSinceSync = false;
                        __lastGeneratedCode = '';
                        return;
                    }
                    let rebuilt = false;
                    try { rebuilt = deserializeWorkspaceColumns(txt, true); } catch(_){ rebuilt = false; }
                    __userEditedSinceSync = !rebuilt;
                    if (rebuilt) showCode();
                }, 400);
            };
            codeEl.addEventListener('input', () => { __userEditedSinceSync = true; scheduleParse(); });
            codeEl.addEventListener('paste', () => { __userEditedSinceSync = true; setTimeout(scheduleParse, 50); });
        }

        // Display page load time
        document.addEventListener('DOMContentLoaded', function() {
            const updateTimeElement = document.getElementById('updateTime');
            if (updateTimeElement) {
                updateTimeElement.textContent = new Date().toLocaleString();
            }
        });

        const exampleXml = `
        <xml xmlns="https://developers.google.com/blockly/xml">
            <block type="when_start_clicked" x="20" y="20">
                <next>
                    <block type="print_output">
                        <value name="TEXT">
                            <block type="text">
                                <field name="TEXT">🎮 Getting Roblox services...</field>
                            </block>
                        </value>
                        <next>
                            <block type="variables_set">
                                <field name="VAR">game</field>
                                <value name="VALUE">
                                    <block type="get_service">
                                        <field name="SERVICE">Workspace</field>
                                    </block>
                                </value>
                                <next>
                                    <block type="variables_set">
                                        <field name="VAR">players</field>
                                        <value name="VALUE">
                                            <block type="get_service">
                                                <field name="SERVICE">Players</field>
                                            </block>
                                        </value>
                                        <next>
                                            <block type="variables_set">
                                                <field name="VAR">localPlayer</field>
                                                <value name="VALUE">
                                                    <block type="get_local_player"></block>
                                                </value>
                                                <next>
                                                    <block type="print_output">
                                                        <value name="TEXT">
                                                            <block type="text_join">
                                                                <mutation items="2"></mutation>
                                                                <value name="ADD0">
                                                                    <block type="text">
                                                                        <field name="TEXT">👤 Local player: </field>
                                                                    </block>
                                                                </value>
                                                                <value name="ADD1">
                                                                    <block type="get_instance_name">
                                                                        <value name="INSTANCE">
                                                                            <block type="variables_get">
                                                                                <field name="VAR">localPlayer</field>
                                                                            </block>
                                                                        </value>
                                                                    </block>
                                                                </value>
                                                            </block>
                                                        </value>
                                                        <next>
                                                            <block type="variables_set">
                                                                <field name="VAR">character</field>
                                                                <value name="VALUE">
                                                                    <block type="get_character">
                                                                        <value name="PLAYER">
                                                                            <block type="variables_get">
                                                                                <field name="VAR">localPlayer</field>
                                                                            </block>
                                                                        </value>
                                                                    </block>
                                                                </value>
                                                                <next>
                                                                    <block type="controls_if">
                                                                        <value name="IF0">
                                                                            <block type="logic_compare">
                                                                                <field name="OP">NEQ</field>
                                                                                <value name="A">
                                                                                    <block type="variables_get">
                                                                                        <field name="VAR">character</field>
                                                                                    </block>
                                                                                </value>
                                                                                <value name="B">
                                                                                    <block type="logic_null"></block>
                                                                                </value>
                                                                            </block>
                                                                        </value>
                                                                        <statement name="DO0">
                                                                            <block type="print_output">
                                                                                <value name="TEXT">
                                                                                    <block type="text">
                                                                                        <field name="TEXT">✅ Character found! Ready to use Roblox API.</field>
                                                                                    </block>
                                                                                </value>
                                                                            </block>
                                                                        </statement>
                                                                    </block>
                                                                </next>
                                                            </block>
                                                        </next>
                                                    </block>
                                                </next>
                                            </block>
                                        </next>
                                    </block>
                                </next>
                            </block>
                        </next>
                    </block>
                </next>
            </block>
        </xml>`;
        
        // Load example XML using compatible API
        try {
            const dom = Blockly.Xml.textToDom(exampleXml);
            Blockly.Xml.domToWorkspace(dom, workspace);
        } catch (e) {
            console.log('XML loading failed:', e);
            // Fallback: just show empty workspace
        }
        // Force dark styling in case Blockly injects late styles
        function applyDarkFixes(){
            const toRecolor = document.querySelectorAll('.blocklyToolboxDiv, .blocklyFlyoutBackground, .blocklyFlyout');
            toRecolor.forEach(el=>{ el.style.background = '#161b22'; });
        }
        applyDarkFixes();
        setTimeout(applyDarkFixes, 250);
        setTimeout(applyDarkFixes, 1000);
        const obs = new MutationObserver(()=>applyDarkFixes());
        obs.observe(document.body,{childList:true,subtree:true});
    
    // --- Custom Column/Table Based Serialization Format ---
    // Spec Overview:
    // Root object: { version: 1, variables: [{name,type,id}], columns: [ Column, ... ] }
    // Column: { id, x, y, blocks: [ Block, ... ] }
    // Block: { type, fields:{name:value}, mutation?:string, inputs:{ inputName: Value | { columns:[Column] } } , shadow?:bool }
    // Value (for value inputs): { block: Block } (single nested block tree) OR primitive literal string/number if we later optimize.
    // Statement inputs become nested column sets: { columns:[Column] } allowing multi-stack bodies (e.g. IF with ELSE, ELSEIF future).
    // Positions only stored for heads of each column (top-most block). Nested statement columns also get pseudo x,y relative to parent (optional: we store parent offset for clarity).

    function collectVariablesForColumnsFormat(ws){
        try { return ws.getAllVariables().map(v=>({name:v.name, type:v.type||'', id:v.getId()})); } catch(_){ return []; }
    }

    function blockToPlain(block, visited){
        if(!block || visited.has(block.id)) return null;
        visited.add(block.id);
        const obj = { type: block.type, fields:{}, inputs:{} };
        // Fields
        if(block.inputList){
            block.inputList.forEach(inp=>{
                if(inp.fieldRow){
                    inp.fieldRow.forEach(f=>{ if(f && typeof f.getValue === 'function' && f.name){ obj.fields[f.name]=f.getValue(); }});
                }
            });
        }
        // Mutation
        if(typeof block.mutationToDom === 'function'){
            try { const m = block.mutationToDom(); if(m){ obj.mutation = m.outerHTML; } } catch(_){ }
        }
        // Inputs (value & statement)
        if(block.inputList){
            block.inputList.forEach(inp=>{
                if(!inp.name) return;
                const target = inp.connection && inp.connection.targetBlock && inp.connection.targetBlock();
                if(!target) return;
                if(inp.type === Blockly.NEXT_STATEMENT || inp.type === Blockly.INPUT_STATEMENT){
                    // Statement chain => nested columns (could be multiple stacks if chain splits, but usually linear)
                    const nestedHead = target; // head of nested column
                    const nestedColumns = [];
                    const col = plainifyColumn(nestedHead, visited, true);
                    if(col) nestedColumns.push(col);
                    if(nestedColumns.length){ obj.inputs[inp.name] = { columns: nestedColumns }; }
                } else { // Value input
                    const valPlain = blockToPlain(target, visited);
                    if(valPlain) obj.inputs[inp.name] = { block: valPlain };
                }
            });
        }
        return obj;
    }

    function plainifyColumn(headBlock, visited, isNested){
        if(!headBlock) return null;
        // Gather linear stack (linked by nextConnection)
        const headXY = headBlock.getRelativeToSurfaceXY();
        const column = { id: headBlock.id, x: headXY.x, y: headXY.y, blocks: [] };
        if(isNested){ column.isNested = true; }
        let cur = headBlock;
        while(cur){
            const p = blockToPlain(cur, visited);
            if(p) column.blocks.push(p);
            const next = cur.getNextBlock && cur.getNextBlock();
            cur = next;
        }
        return column;
    }

    window.serializeWorkspaceColumns = function(){
        try {
            const ws = workspace;
            const visited = new Set();
            const topBlocks = ws.getTopBlocks(true);
            const columns = topBlocks.map(tb=>plainifyColumn(tb, visited, false)).filter(Boolean);
            const data = { version:1, generated:new Date().toISOString(), variables: collectVariablesForColumnsFormat(ws), columns };
            const json = JSON.stringify(data, null, 2);
            console.log('Serialized columns format:', data);
            return json;
        } catch(e){
            console.error('serializeWorkspaceColumns error', e); return '{}';
        }
    };

    function applyPlainBlock(ws, plain){
        if(!plain) return null;
        let b;
        try { b = ws.newBlock(plain.type); } catch(e){ console.warn('Unknown block type', plain.type); return null; }
        // Fields
        if(plain.fields){
            for(const k in plain.fields){
                try { b.setFieldValue(String(plain.fields[k]), k); } catch(_){ }
            }
        }
        // Mutation
        if(plain.mutation && typeof b.domToMutation === 'function'){
            try {
                const div = document.createElement('div'); div.innerHTML = plain.mutation.trim();
                const mutNode = div.firstElementChild; if(mutNode) b.domToMutation(mutNode);
            } catch(_){ }
        }
        // Value inputs
        if(plain.inputs){
            for(const inputName in plain.inputs){
                const spec = plain.inputs[inputName];
                if(spec && spec.block){
                    const child = applyPlainBlock(ws, spec.block);
                    if(child){
                        const inp = b.getInput(inputName);
                        if(inp && inp.connection && child.outputConnection){
                            try { inp.connection.connect(child.outputConnection); } catch(_){ }
                        }
                    }
                }
            }
        }
        b.initSvg && b.initSvg();
        b.render && b.render();
        // Statement inputs (after value so blocks exist)
        if(plain.inputs){
            for(const inputName in plain.inputs){
                const spec = plain.inputs[inputName];
                if(spec && spec.columns){
                    // Only first column chain connected (Blockly statements single chain). Extra columns ignored for now.
                    const firstCol = spec.columns[0];
                    if(firstCol){
                        let prevInChain = null;
                        firstCol.blocks.forEach(blockPlain=>{
                            const child = applyPlainBlock(ws, blockPlain);
                            if(!child) return;
                            if(!prevInChain){
                                const inp = b.getInput(inputName);
                                if(inp && inp.connection && child.previousConnection){
                                    try { inp.connection.connect(child.previousConnection); } catch(_){ }
                                }
                            } else if(prevInChain.nextConnection && child.previousConnection){
                                try { prevInChain.nextConnection.connect(child.previousConnection); } catch(_){ }
                            }
                            prevInChain = child;
                        });
                    }
                }
            }
        }
        return b;
    }

    window.deserializeWorkspaceColumns = function(json, clear=true){
        try {
            const data = (typeof json === 'string') ? JSON.parse(json) : json;
            if(!data || !Array.isArray(data.columns)) throw new Error('Invalid columns format');
            if(clear) workspace.clear();
            // Variables
            if(Array.isArray(data.variables)){
                data.variables.forEach(v=>{ try { workspace.createVariable(v.name, v.type||'', v.id); } catch(_){ } });
            }
            // Columns
            data.columns.forEach(col=>{
                if(!col || !Array.isArray(col.blocks) || !col.blocks.length) return;
                let prev = null;
                col.blocks.forEach(pb=>{
                    const created = applyPlainBlock(workspace, pb);
                    if(!created) return;
                    if(!prev){
                        try { created.moveBy(col.x || 20, col.y || 20); } catch(_){ }
                    } else if(prev.nextConnection && created.previousConnection){
                        try { prev.nextConnection.connect(created.previousConnection); } catch(_){ }
                    }
                    prev = created;
                });
            });
            workspace.refreshToolboxSelection && workspace.refreshToolboxSelection();
            showCode();
            return true;
        } catch(e){ console.error('deserializeWorkspaceColumns error', e); return false; }
    };

    // Optional: export to a Lua-like table string for external storage
    window.columnsJsonToLua = function(json){
        try {
            const data = (typeof json === 'string') ? JSON.parse(json) : json;
            function esc(str){ return String(str).replace(/\\/g,'\\\\').replace(/"/g,'\\"'); }
            function blockToLua(b){
                let parts = [`type="${esc(b.type)}"`];
                if(b.fields && Object.keys(b.fields).length){
                    const f = Object.entries(b.fields).map(([k,v])=>`${k}="${esc(v)}"`).join(',');
                    parts.push(`fields={${f}}`);
                }
                if(b.inputs){
                    const inpParts = [];
                    for(const k in b.inputs){
                        const spec = b.inputs[k];
                        if(spec.block){ inpParts.push(`${k}={block=${blockToLua(spec.block)}}`); }
                        if(spec.columns){ inpParts.push(`${k}={columns={${spec.columns.map(c=>columnToLua(c)).join(',')}}}`); }
                    }
                    if(inpParts.length) parts.push(`inputs={${inpParts.join(',')}}`);
                }
                return `{${parts.join(',')}}`;
            }
            function columnToLua(c){
                return `{x=${c.x||0},y=${c.y||0},blocks={${c.blocks.map(b=>blockToLua(b)).join(',')}}}`;
            }
            const lua = `return {version=${data.version||1},columns={${data.columns.map(c=>columnToLua(c)).join(',')}}}`;
            return lua;
        } catch(e){ return '-- lua export failed: '+e.message; }
    };

    // Hook up buttons
    // Tabs system
    let __tabs = [];// {id,name,hash,contentJson,lastSaved}
    let __activeTabId = null;
    const EMPTY_PROGRAM_JSON = () => JSON.stringify({version:1,generated:new Date().toISOString(),variables:[],columns:[]},null,2);
    let __autosaveTimer = null;
    let __workspaceDirty = false;
    const PROGRAM_BASE_DIR = 'HyntheraAssets'; // native host should map to C:/ProgramData/HyntheraAssets/
    const PROGRAM_SUB_DIR = 'programs';        // final path: C:/ProgramData/HyntheraAssets/programs

    function newTabName(base='Program'){
        let i=1; while(__tabs.some(t=>t.name===base+i)) i++; return base+i;
    }
    function createTab(name, contentJson){
        // Save current active before creating new blank
        saveActiveTab();
        const id = Math.random().toString(36).slice(2,12);
        const hash = id.slice(0,6);
        const tab = {id, hash, name: name||newTabName(), contentJson: contentJson || EMPTY_PROGRAM_JSON(), lastSaved:null};
        __tabs.push(tab);
        renderTabs();
        setActiveTab(id,false);
        requestAnimationFrame(()=>{ const bar=document.getElementById('tabsBar'); if(bar) bar.scrollLeft = bar.scrollWidth; });
        saveProgram(tab); // initial save
        return tab;
    }
    function deleteTab(id){
        const idx = __tabs.findIndex(t=>t.id===id);
        if(idx===-1) return;
        const removed = __tabs.splice(idx,1)[0];
        if(removed) { postDeleteProgram(removed); }
        if(__activeTabId===id){ __activeTabId = __tabs[0] ? __tabs[0].id : null; if(__activeTabId) loadTabIntoWorkspace(__activeTabId); else { workspace.clear(); createTab(); } }
        renderTabs(); saveTabs(); showCode();
    }
    function setActiveTab(id, saveCurrent=true){
        if(saveCurrent && __activeTabId){
            const current = __tabs.find(t=>t.id===__activeTabId);
            if(current){ current.contentJson = serializeWorkspaceColumns(); }
        }
        __activeTabId = id;
        loadTabIntoWorkspace(id);
        renderTabs();
    }
    function loadTabIntoWorkspace(id){
        const t = __tabs.find(x=>x.id===id); if(!t) return;
        try { deserializeWorkspaceColumns(t.contentJson, true); } catch(_){ workspace.clear(); }
        __userEditedSinceSync = false; showCode();
        __workspaceDirty = false;
    }
    function renderTabs(){
        const bar = document.getElementById('tabsBar'); if(!bar) return;
        Array.from(bar.querySelectorAll('.tabBtn')).forEach(n=>n.remove());
        __tabs.forEach(tab=>{
            const btn = document.createElement('div');
            btn.className='tabBtn';
            btn.style.cssText='flex:0 0 auto; position:relative; display:flex; align-items:center; max-width:220px; padding:6px 30px 6px 12px; background:'+(tab.id===__activeTabId?'#00d4aa':'#30363d')+'; color:#fff; border-radius:5px; font-size:12px; cursor:pointer; user-select:none; font-weight:'+(tab.id===__activeTabId?'600':'500')+';';
            btn.textContent=tab.name;
            const close=document.createElement('span');
            close.textContent='×';
            close.style.cssText='position:absolute; right:6px; top:2px; font-weight:800; font-size:18px; line-height:16px; padding:0 4px;';
            close.onclick=(e)=>{ e.stopPropagation(); deleteTab(tab.id); };
            btn.appendChild(close);
            btn.ondblclick=()=>{ startRenameTab(tab.id, btn); };
            btn.onclick=()=>{ if(tab.id!==__activeTabId) setActiveTab(tab.id); };
            // Drag & drop
            btn.draggable = true;
            btn.addEventListener('dragstart', e=>{ e.dataTransfer.setData('text/plain', tab.id); e.dataTransfer.effectAllowed='move'; });
            btn.addEventListener('dragover', e=>{ e.preventDefault(); });
            btn.addEventListener('drop', e=>{ e.preventDefault(); const dragId = e.dataTransfer.getData('text/plain'); if(!dragId||dragId===tab.id) return; reorderTabs(dragId, tab.id); });
            bar.insertBefore(btn, document.getElementById('addTabBtn'));
        });
        bar.style.overflowX = (__tabs.length>6)?'auto':'hidden';
        if(__tabs.length>6) bar.scrollLeft = bar.scrollWidth;
    }
    function reorderTabs(dragId, targetId){
        const from = __tabs.findIndex(t=>t.id===dragId); const to = __tabs.findIndex(t=>t.id===targetId);
        if(from===-1||to===-1||from===to) return;
        const [m] = __tabs.splice(from,1);
        __tabs.splice(to,0,m);
        renderTabs(); saveTabs();
    }
    function startRenameTab(id, btn){
        const tab = __tabs.find(t=>t.id===id); if(!tab) return;
        const input = document.createElement('input');
        input.type='text'; input.value=tab.name; input.style.cssText='width:100%; border:none; outline:none; font-size:11px; background:#111; color:#fff; padding:2px 18px 2px 4px; border-radius:3px;';
        btn.innerHTML=''; btn.appendChild(input); input.focus(); input.select();
        const finish=(commit)=>{ if(commit){ const v=input.value.trim(); if(v) tab.name=v; } renderTabs(); saveTabs(); };
        input.onblur=()=>finish(true);
        input.onkeydown=e=>{ if(e.key==='Enter') finish(true); else if(e.key==='Escape') finish(false); };
    }
    function sanitizeFileName(n){ return n.replace(/[^a-zA-Z0-9._ -]/g,'_').slice(0,60); }
    function saveProgram(tab){
        if(!tab) return;
        const json = serializeWorkspaceColumns();
        // Determine if workspace has at least one block (avoid saving truly empty programs)
        try {
            const parsed = JSON.parse(json);
            const hasBlocks = parsed && parsed.columns && parsed.columns.some(c=>c.blocks && c.blocks.length);
            if(!hasBlocks) return; // skip saving empty
        } catch(_){ return; }
        tab.contentJson = json;
        tab.lastSaved = json;
        try {
            const fileName = sanitizeFileName(tab.name)+'_'+tab.hash+'.json';
            const payload = { id: (crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2)), function:'saveProgram', params:{ fileName, content:tab.contentJson }};
            if(window.chrome && window.chrome.webview){ window.chrome.webview.postMessage(JSON.stringify(payload)); }
            else {
                const all = JSON.parse(localStorage.getItem('hynthera_programs_v2')||'[]');
                const idx = all.findIndex(p=>p.hash===tab.hash);
                if(idx>-1) all[idx]={name:tab.name, hash:tab.hash, content:tab.contentJson}; else all.push({name:tab.name, hash:tab.hash, content:tab.contentJson});
                localStorage.setItem('hynthera_programs_v2', JSON.stringify(all));
            }
        } catch(_){ }
    }
    function postDeleteProgram(tab){
        try { const fileName = sanitizeFileName(tab.name)+'_'+tab.hash+'.json'; const payload = { id:(Math.random().toString(36).slice(2)), function:'deleteProgram', params:{ fileName }}; if(window.chrome && window.chrome.webview) window.chrome.webview.postMessage(JSON.stringify(payload)); else {
            const all = JSON.parse(localStorage.getItem('hynthera_programs_v2')||'[]').filter(p=>p.hash!==tab.hash); localStorage.setItem('hynthera_programs_v2', JSON.stringify(all));
        } } catch(_){ }
    }
    function saveTabs(){ // batch convenience
        __tabs.forEach(t=>saveProgram(t));
    }
    function saveActiveTab(){ const t = __tabs.find(x=>x.id===__activeTabId); if(t) saveProgram(t); }
    function loadTabsFromStorage(){
        try { if(window.chrome && window.chrome.webview){ window.chrome.webview.postMessage(JSON.stringify({id:(Math.random().toString(36).slice(2)), function:'loadProgramsRequest', params:{}})); setTimeout(()=>{ if(!__tabs.length) loadTabsLocal(); },800); } else loadTabsLocal(); } catch(_){ loadTabsLocal(); }
    }
    function loadTabsLocal(){
        try { const raw = localStorage.getItem('hynthera_programs_v2'); if(raw){ const arr=JSON.parse(raw); if(Array.isArray(arr)){ const seen=new Set(); arr.forEach(p=>{ const h=(p.hash||'').toString(); if(h && seen.has(h)) return; seen.add(h); const id = Math.random().toString(36).slice(2,12); __tabs.push({id, name:p.name, hash:h||id.slice(0,6), contentJson:p.content, lastSaved:p.content}); }); } } } catch(_){ }
        if(!__tabs.length) createTab('Program1');
        setActiveTab(__tabs[0].id,false);
    }
    // Listen for native response
    window.addEventListener('message', e=>{
        try {
            const data = JSON.parse(e.data);
            // Ignore legacy unknown function errors (empty function name)
            if(data && data.error && data.error.startsWith('Unknown function')) return;
            if(Array.isArray(data.programs)) { // load programs response
                const incoming = data.programs;
                const existingHashes = new Set(__tabs.map(t=>t.hash));
                // Replace full set, but dedupe by hash
                __tabs=[]; const seen=new Set();
                incoming.forEach(p=>{ const id=Math.random().toString(36).slice(2,12); const h=(p.hash||'').toString()||id.slice(0,6); if(seen.has(h)) return; seen.add(h); __tabs.push({id, name:p.name, hash:h, contentJson:p.content, lastSaved:p.content}); });
                if(__tabs.length) setActiveTab(__tabs[0].id,false); else createTab('Program1');
            }
        } catch(_){ }
    });
    document.addEventListener('DOMContentLoaded',()=>{
        const addTab = document.getElementById('addTabBtn'); if(addTab){ addTab.onclick=()=>createTab(); }
        loadTabsFromStorage();
    });

    // Autosave after inactivity 0.4s when different from lastSaved; skip empty workspaces
    workspace.addChangeListener(function(ev){
        if(ev.type===Blockly.Events.UI) return;
        __workspaceDirty = true;
        if(__autosaveTimer) clearTimeout(__autosaveTimer);
        __autosaveTimer = setTimeout(()=>{
            const active = __tabs.find(t=>t.id===__activeTabId); if(!active) return;
            const current = serializeWorkspaceColumns();
            if(current !== active.lastSaved){
                try {
                    const parsed = JSON.parse(current);
                    const hasBlocks = parsed && parsed.columns && parsed.columns.some(c=>c.blocks && c.blocks.length);
                    if(hasBlocks){ active.contentJson = current; saveProgram(active); }
                } catch(_){ }
            }
            __workspaceDirty = false;
        },400);
    });

    (function(){
        const exportBtn = document.getElementById('exportBlocksBtn');
        const importBtn = document.getElementById('importBlocksBtn');
        if(exportBtn){
            exportBtn.addEventListener('click', ()=>{
                const json = serializeWorkspaceColumns();
                window.__lastExportColumnsJSON = json;
                // Place into code textarea (non-destructive) for quick copy
                try {
                    const codeInput = document.getElementById('codeInput');
                    if(codeInput){ codeInput.value = json; __userEditedSinceSync = true; }
                } catch(_){ }
                if(navigator.clipboard){ navigator.clipboard.writeText(json).catch(()=>{}); }
                hynthera_output('📤 Exported blocks to custom column JSON (copied to clipboard)');
            });
        }
        if(importBtn){
            importBtn.addEventListener('click', ()=>{
                const raw = prompt('Paste column JSON (or Lua not yet supported for import):');
                if(!raw) return;
                const ok = deserializeWorkspaceColumns(raw, true);
                hynthera_output(ok ? '📥 Imported column format successfully' : '❌ Failed to import column format');
            });
        }
    })();
    // --- End Custom Column/Table Based Serialization ---
    showCode();
    </script>
        <!--
        Worker Loop Architecture Notes:
        - File: loop_worker.js handles high-frequency (target 120 FPS) loop execution.
        - Main thread decides to offload when generated code contains 'while(' or 'for('.
        - RobloxAPI calls inside worker are proxied: worker sends {type:'backendCall', fn, args}; main thread invokes real RobloxAPI and returns result.
        - Output from worker forwarded as {type:'log', entry} and rendered through existing hynthera_output pipeline.
        - Fallback: If Worker unsupported, inline executeCodeSafely() runs with dynamic FPS (default 120 when requested).
        - Debug toggle: window.__ROBLOX_DEBUG = false; to silence per-call logging.
        Next Potential Enhancements:
            * Add progress HUD showing loop iteration rate.
            * Persist __ROBLOX_DEBUG preference in localStorage.
            * Add block that explicitly requests worker or sets desired FPS.
            * Surface backend error stack traces (if available) in a collapsible panel.
        -->
</body>
</html>
